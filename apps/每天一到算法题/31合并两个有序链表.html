<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        /**
         * 定义链表节点
         */
        function ListNode(val, next) {
            this.val = (val === undefined ? 0 : val)
            this.next = (next === undefined ? null : next)
        }

        /**
         * 合并两个有序链表
         * 
         * 时间复杂度：O(n + m) - n 和 m 分别是两个链表的长度
         * 空间复杂度：O(1) - 只需要常数级别的额外空间
         */
        function mergeTwoLists(list1, list2) {
            // 1. 创建一个“哑节点”(dummy node)，方便处理头节点逻辑
            let dummy = new ListNode(-1);
            let current = dummy;

            // 2. 只要两个链表都不为空，就一直比较
            while (list1 !== null && list2 !== null) {
                if (list1.val <= list2.val) {
                    current.next = list1;
                    list1 = list1.next; // 移动 list1 指针
                } else {
                    current.next = list2;
                    list2 = list2.next; // 移动 list2 指针
                }
                current = current.next; // 移动合并后的链表指针
            }

            // 3. 循环结束，如果其中一个链表还有剩余，直接挂在末尾
            // 因为链表是有序的，剩余部分肯定比已合并的所有节点都大
            current.next = (list1 !== null) ? list1 : list2;

            // 4. 返回哑节点的下一个节点，即真正的合并后头节点
            return dummy.next;
        }

        // --- 测试代码 ---
        const l1 = new ListNode(1, new ListNode(2, new ListNode(4)));
        const l2 = new ListNode(1, new ListNode(3, new ListNode(4)));

        console.log('链表1: 1->2->4');
        console.log('链表2: 1->3->4');
        
        const merged = mergeTwoLists(l1, l2);
        
        // 打印结果函数
        function printList(head) {
            let res = [];
            while(head) {
                res.push(head.val);
                head = head.next;
            }
            console.log('合并后:', res.join('->'));
        }
        printList(merged);
    </script>
</body>
</html>