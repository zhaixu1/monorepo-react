# 数据结构

## 线性结构

### 数组

1. 内存结构：连续存储。
   
   数组在内存中占据一块连续的空间。计算机可以通过首地址和下标（索引）直接计算出任意元素的内存地址。
2. 核心优势：随机访问

    无论数据多大，访问任意位置元素的时间都是固定的
    时间复杂度：O(1)
3. 缺点：插入和删除效率低

    插入：如果在数组中间或者开头插入一个元素，为了保持连续性，必须把插入点之后的所有元素后移一位。

### 链表
1. 什么是链表？
    链表就像是一个个节点串起来的，每一个节点包含两部分：
    - 数据域：存你看中的值
    - 指针域：存下一个节点的地址。
  ```js
  // 用 JS 对象简单表示一个节点
const node = {
    value: 10,      // 数据
    next: nextNode  // 指向下一个节点的引用
}
```

2. 链表和数组的对比？

- 内存空间
  - 数组：必须申请一块完整的连续的地址，如果内存剩下很多碎小空间，但没有一块大的，数据就申请失败。
  - 链表：见缝插针。只要有一块空地就能塞一个节点。通过指针链接起来，不要求内存连续。
- 增删操作
  - 数组：后面所有人都要往后挪一步，腾出位置。空间复杂度O(n)
  - 链表：让前一个的next指向新的数据，新的数据的next指向原来的。复杂度 O(1)
- 查询操作：
  - 数组：因为在内存中数组的地址都是固定的，所以O(1)
  - 链表：必须从第一个开始，一直到第n个。复杂度O(n)
  
3. 单向链表 
   
- 只能从头走到尾，不能回头（像过河卒）

4. 双向链表
- 双向链表：每个节点有两个指针（prev 和 next）。既能往后找，也能往前找。比如音乐播放器的“上一首”和“下一首”。


### 栈
1. 特点：先进后出
2. 入栈：push
3. 出栈：pop
4. 查找时间复杂度O(n),需要重上面的开始进行遍历。

### 队列

1. 核心规则：队列有两个口，分别负责进和出
2. 入队，从队尾添加元素
3. 出队：从队头添加元素

4. 双端队列：
   - 特点：两头都通气，对头和队尾都可以进行入队和出队。
   - 场景：它既能当栈用（一边进出），也能当队列用（两边进出）。JS 的数组其实就是一个天然的双端队列（push/pop 处理尾部，unshift/shift 处理头部）。
5.  优先队列
   - 特性： VIP 插队模式。元素不仅有值，还有优先级
   - 规则：出队时，不是看谁先开的，而是看谁的优先级最高


### 哈希表 (Hash Table)
1. **核心原理**: 通过一个哈希函数，把任意长度的 **Key** 映射成固定长度的 **数组下标**。
2. **映射步骤**:
   - `Hash Code = HashFunction(key)` (把 Key 变成大整数)
   - `Index = HashCode % ArrayLength` (把大整数缩减到数组范围内)
3. **哈希冲突 (Collision)**:
   - **定义**: 不同的 Key 算出了相同的下标。
   - **实例**: 假设简单求和哈希且数组长度为 79：
     - "apple" -> 求和 530 -> `530 % 79 = 56`
     - "banana" -> 求和 609 -> `609 % 79 = 56` (撞车了！)
   - **解决方法**:
     - **拉链法 (Chaining)**: 数组每个位置存一个链表，冲突的元素直接挂在链表后面（最常用）。
     - **开放地址法**: 找附近的空位坐下。
4. **复杂度**: 理想情况下增删改查都是 **O(1)**。


## 非线性结构

### 树 (Tree)

树是一种分层数据的抽象模型。就像大自然的树倒过来：根在上，叶子在下。

#### 1. 基础概念
- **根节点 (Root)**: 树最顶端的节点。
- **子节点 (Child)**: 一个节点延伸出去的下级节点。
- **叶子节点 (Leaf)**: 没有子节点的节点（光杆司令）。
- **深度/高度**: 树有多少层。

#### 2. 二叉树家族 (Binary Tree)
最基础、最常用的树。每个节点**最多有两个孩子**（左孩子、右孩子）。

- **完全二叉树**: 
    - 除了最后一层，其他层都是满的。
    - 最后一层的节点都靠左排列。
    - *应用*: 堆 (Heap) 就是一种完全二叉树。

- **二叉搜索树 (BST - Binary Search Tree)**:  
    - 重要
    - **规则**: 左孩子 < 父节点 < 右孩子。
    - **优点**: 查找速度快，类似二分查找。时间复杂度平均 O(log n)。
    - **缺点**: 如果插入数据有序（1,2,3,4），会退化成“链表”，复杂度变 O(n)。

- **平衡二叉树 (AVL 树)**:
    - **规则**: 严格控制左右子树高度差不超过 1。
    - **机制**: 每次插入/删除如果不平衡，立即通过“旋转”来调整。
    - **特点**: 查询极快，但插入/删除慢（因为要一直旋转调整）。

- **红黑树 (Red-Black Tree)**:
    - **规则**: 一种“弱平衡”二叉树。不追求绝对高度差为 1，只要大致平衡。
    - **特点**: 在查询、插入、删除之间找到了完美的平衡点。
    - **应用**: Java 的 `HashMap`, `TreeMap`；C++ 的 `std::map`。

#### 3. 多路搜索树 (Multi-way Search Tree)
节点可以有多个孩子，主要用于处理大量数据存储（如硬盘、数据库）。

- **B 树 (B-Tree)**:
    - **特点**: 一个节点可以存多个 key，有多个孩子（比如 100 阶 B 树，一个节点可以有 100 个孩子）。
    - **优势**: 树的高度非常低（矮胖型）。查找时读取硬盘次数少。

- **B+ 树 (B+ Tree)**:
    - **特点**: B 树的升级版。**数据只存在叶子节点**，非叶子节点只存索引。所有叶子节点连成一个链表。
    - **应用**: **数据库索引 (MySQL)** 的核心数据结构。能支持范围查找（如 `WHERE age > 20`）。

#### 4. 特殊用途的树

- **堆 (Heap)**:
    - **特点**: 特殊的完全二叉树。
    - **大顶堆**: 根节点最大。
    - **小顶堆**: 根节点最小。
    - **应用**: 优先队列、任务调度、TopK 排序。

- **字典树 (Trie)**:
    - **特点**: 专门处理字符串。节点存字符，路径组成单词。
    - **应用**: 搜索框自动补全、拼写检查。

- **哈夫曼树 (Huffman Tree)**:
    - **特点**: 带权路径长度最短的树。
    - **应用**: 数据压缩（ZIP 压缩算法核心）。频率高的字符编码短，频率低的编码长。

### 🛑 老师的避坑指南 (必看)

| 树的类型 | 学习策略 (死磕程度) | 核心考点 |
| :--- | :--- | :--- |
| **二叉搜索树 (BST)** | ⭐⭐⭐⭐⭐ (动手写代码) | 1. 验证 BST <br> 2. 最近公共祖先 <br> 3. 中序遍历是有序的 (重点) |
| **普通二叉树** | ⭐⭐⭐⭐⭐ (动手写代码) | 1. 递归遍历 (前中后序) <br> 2. 层序遍历 (BFS) <br> 3. 求深度/翻转二叉树 |
| **完全二叉树 / 堆** | ⭐⭐⭐ (理解 + 数组) | 1. TopK 问题 (前 K 个最大值) <br> 2. 数组和树的下标换算 |
| **红黑树 / AVL** | ⭐ (动口不动手) | **不要尝试手写代码！** <br> 1. 知道它们是为了解决 BST 退化问题 <br> 2. 知道 Map/Set 底层是红黑树 |
| **B+ 树** | ⭐⭐⭐⭐ (理论原理) | **数据库面试必问！** <br> 1. 为什么 MySQL 用 B+ 树不用红黑树？(因为矮胖，减少磁盘 IO) |

## 刷题清单 (LeetCode)

### 1. 普通二叉树 (基本功)

**遍历类 (必须背诵)**
- [144] 二叉树的前序遍历
- [94] 二叉树的中序遍历
- [145] 二叉树的后序遍历
- [102] 二叉树的层序遍历 (BFS)

**属性/深度类**
- [104] 二叉树的最大深度 (DFS/BFS)
- [111] 二叉树的最小深度
- [110] 平衡二叉树 (判断是否平衡)
- [101] 对称二叉树 (镜像判断)
- [226] 翻转二叉树 (Google 面试名题)

**路径/祖先类**
- [112] 路径总和 (是否有路径等于目标值)
- [236] 二叉树的最近公共祖先 (LCA)
- [257] 二叉树的所有路径

---

### 2. 二叉搜索树 (BST 特性)

**验证与搜索**
- [98] 验证二叉搜索树 (Validate BST) - *经典坑题*
- [700] 二叉搜索树中的搜索
- [235] 二叉搜索树的最近公共祖先 (比普通树简单，利用大小关系)

**构造与修改**
- [108] 将有序数组转换为二叉搜索树 (构建平衡树)
- [450] 删除二叉搜索树中的节点 (难点)
- [701] 二叉搜索树中的插入操作

**利用中序有序性 (BST 核心)**
- [230] 二叉搜索树中第 K 小的元素
- [530] 二叉搜索树的最小绝对差
- [501] 二叉搜索树中的众数
