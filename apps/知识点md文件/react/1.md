# React Fiber 深度解析

## fiber是什么，实现框架逻辑

### 定义
React Fiber 是 React 16 引入的新协调（reconciliation）引擎，它重写了 React 的核心算法。

**两层含义：**
1. **架构层面**：一种支持增量渲染的协调算法
2. **数据结构层面**：描述组件树结构的 Fiber 节点

### 核心架构

#### 1. Fiber 节点数据结构
```javascript
function FiberNode() {
  // 节点基本信息
  this.tag = null;          // 节点类型
  this.type = null;         // 元素类型
  this.stateNode = null;    // 对应的DOM节点或组件实例

  // Fiber 树关系
  this.return = null;       // 父节点
  this.child = null;        // 第一个子节点
  this.sibling = null;      // 兄弟节点

  // 状态管理
  this.pendingProps = null; // 新props
  this.memoizedProps = null;// 上次渲染props
  this.memoizedState = null;// 上次渲染state
  this.updateQueue = null;  // 更新队列

  // 副作用链
  this.effectTag = null;    // 副作用标记
  this.nextEffect = null;   // 下一个副作用节点

  // 优先级调度
  this.lanes = null;        // 优先级车道
  this.alternate = null;    // 双缓存指针
}
```

#### 2. 双缓存机制
维护两棵 Fiber 树实现无缝切换：
- **Current Tree**：当前屏幕显示的树
- **WorkInProgress Tree**：内存中构建的新树

#### 3. 工作流程

**Render阶段（可中断）：**
```javascript
function workLoopConcurrent() {
  while (workInProgress !== null && !shouldYield()) {
    workInProgress = performUnitOfWork(workInProgress);
  }
}
```

**Commit阶段（不可中断）：**
1. BeforeMutation：执行DOM操作前
2. Mutation：执行DOM操作
3. Layout：调用生命周期钩子

## fiber 出现解决了什么问题？优势是什么？

### 传统 React 存在的问题

#### Stack Reconciler 缺陷：
1. **同步渲染**：一旦开始更新就无法中断
2. **阻塞主线程**：大组件树更新造成页面卡顿
3. **无优先级**：所有更新同等优先级处理

### Fiber 的优势

#### 1. 时间切片（Time Slicing）
```javascript
// 可中断的工作循环
function workLoopConcurrent() {
  while (workInProgress !== null && !shouldYield()) {
    // 有时间继续工作，没时间就让出控制权
    workInProgress = performUnitOfWork(workInProgress);
  }
}
```

#### 2. 优先级调度
```javascript
// 不同事件对应不同优先级
const SyncLane = 0b0000000000000000000000000000001;     // 同步优先级
const DefaultLane = 0b0000000000000000000000000010000;  // 默认优先级
const IdleLane = 0b0100000000000000000000000000000;     // 空闲优先级

// 点击事件 > 输入事件 > 滚动事件 > 空闲更新
```

#### 3. 增量渲染
- 将大任务分解为小工作单元
- 每个单元完成后检查是否需要让出控制权
- 保证页面响应性和流畅度

#### 4. 并发特性
- **Suspense**：异步组件加载
- **Error Boundary**：错误边界处理
- **并发模式**：非阻塞渲染

## 为什么使用 messageChannel进行任务调度？

### 浏览器事件循环机制

```javascript
// 事件循环优先级：
// 1. 微任务（Promise、queueMicrotask）
// 2. 宏任务（setTimeout、MessageChannel）
// 3. 渲染
```

### 调度器选择对比

#### setTimeout 的问题：
```javascript
setTimeout(() => {
  // 即使设置为0，实际延迟至少4ms（HTML5标准）
  console.log('4ms后执行');
}, 0);
```

#### MessageChannel 的优势：
```javascript
const { port1, port2 } = new MessageChannel();

port2.onmessage = () => {
  // 立即执行，无4ms延迟
  flushWork();
};

function scheduleCallback(callback) {
  taskQueue.push(callback);
  port1.postMessage(null); // 立即触发
}
```

### 为什么选择 MessageChannel？

1. **性能优势**：没有最小4ms延迟限制
2. **时机恰当**：在微任务后，渲染前执行
3. **可控制性**：精确控制任务执行时机
4. **浏览器支持**：现代浏览器都支持

### 调度流程

```javascript
// React 调度器简化版实现
class Scheduler {
  constructor() {
    this.taskQueue = [];
    this.isPerformingWork = false;

    // 创建 MessageChannel
    const { port1, port2 } = new MessageChannel();
    this.port1 = port1;
    this.port2 = port2;

    port2.onmessage = this.performWorkUntilDeadline.bind(this);
  }

  scheduleCallback(priority, callback) {
    const task = { priority, callback };
    this.taskQueue.push(task);

    if (!this.isPerformingWork) {
      this.port1.postMessage(null);
    }
  }

  performWorkUntilDeadline() {
    const deadline = performance.now() + 5; // 5ms时间片

    while (this.taskQueue.length > 0 && performance.now() < deadline) {
      const task = this.taskQueue.shift();
      task.callback();
    }

    if (this.taskQueue.length > 0) {
      // 还有任务，继续调度
      this.port1.postMessage(null);
    }
  }
}
```

## 总结

React Fiber 通过以下创新实现了高性能的并发渲染：

1. **可中断渲染**：时间切片技术防止长时间阻塞
2. **优先级调度**：重要更新优先处理
3. **双缓存机制**：平滑的状态切换
4. **高效调度**：MessageChannel 实现精确的任务调度

这些特性让 React 能够在保持开发体验的同时，提供更好的用户体验。